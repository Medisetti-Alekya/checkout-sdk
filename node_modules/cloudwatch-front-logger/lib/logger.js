"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var client_cloudwatch_logs_1 = require("@aws-sdk/client-cloudwatch-logs");
var Logger = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param accessKeyId     - AWS Access Key ID
     * @param secretAccessKey - AWS Secret Access Key
     * @param region          - AWS Region (e.g. ap-northeast-1)
     * @param logGroupName    - AWS CloudWatch Log Group Name
     */
    function Logger(accessKeyId, secretAccessKey, region, logGroupName) {
        this.accessKeyId = accessKeyId;
        this.secretAccessKey = secretAccessKey;
        this.region = region;
        this.logGroupName = logGroupName;
        this.levels = ['error'];
        this.interval = 10000;
        this.muting = false;
        this.enabled = true;
        this.events = [];
    }
    /**
     * Set level.
     *
     * @param levels - Reported error level
     */
    Logger.prototype.setLevels = function (levels) {
        this.levels = levels;
        return this;
    };
    /**
     * Set interval.
     *
     * @param interval - Interval milliseconds for sending logs
     */
    Logger.prototype.setInterval = function (interval) {
        this.interval = interval;
        return this;
    };
    /**
     * Mute logging in browser console.
     */
    Logger.prototype.mute = function () {
        this.muting = true;
        return this;
    };
    /**
     * Resume logging in browser console.
     */
    Logger.prototype.unmute = function () {
        this.muting = false;
        return this;
    };
    /**
     * Enable collecting errors and sending to AWS CloudWatch.
     */
    Logger.prototype.enable = function () {
        this.enabled = true;
        return this;
    };
    /**
     * Disable collecting errors and sending to AWS CloudWatch.
     */
    Logger.prototype.disable = function () {
        this.enabled = false;
        return this;
    };
    /**
     * Bootstrap Logger.
     *
     * @param logStreamNameResolver - Resolve logStreamName for current user (e.g. Canvas Fingerprint)
     * @param messageFormatter      - Format message string from Error
     * @param Ctor
     * @param storage
     * @param globalConsole
     * @param eventTarget
     */
    Logger.prototype.install = function (_a) {
        var e_1, _b;
        var _this = this;
        var _c = _a === void 0 ? {} : _a, logStreamNameResolver = _c.logStreamNameResolver, messageFormatter = _c.messageFormatter, _d = _c.ClientConstructor, Ctor = _d === void 0 ? client_cloudwatch_logs_1.CloudWatchLogsClient : _d, _e = _c.storage, storage = _e === void 0 ? localStorage : _e, _f = _c.console, globalConsole = _f === void 0 ? console : _f, _g = _c.eventTarget, eventTarget = _g === void 0 ? window : _g;
        this.client = new Ctor({
            credentials: {
                accessKeyId: this.accessKeyId,
                secretAccessKey: this.secretAccessKey,
            },
            region: this.region,
        });
        this.logStreamNameResolver = logStreamNameResolver;
        this.messageFormatter = messageFormatter;
        this.storage = storage;
        // Swap window.console.*() functions and overridden ones
        var originalConsole = {};
        var _loop_1 = function (level) {
            originalConsole[level] = globalConsole[level].bind(globalConsole);
            globalConsole[level] = function (message) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: 
                            // Listen overridden console.*() function calls (type="console", level="*")
                            return [4 /*yield*/, this.onError(new Error(message), { type: 'console', level: level })];
                            case 1:
                                // Listen overridden console.*() function calls (type="console", level="*")
                                _a.sent();
                                if (!this.muting) {
                                    originalConsole[level].apply(originalConsole, tslib_1.__spreadArray([message], tslib_1.__read(args)));
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
        };
        try {
            for (var _h = tslib_1.__values(this.levels), _j = _h.next(); !_j.done; _j = _h.next()) {
                var level = _j.value;
                _loop_1(level);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.console = originalConsole;
        // Listen "error" event on window (type="uncaught")
        eventTarget.addEventListener('error', function (error) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.onError(error, { type: 'uncaught' })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        // Start timer that executes this.onInterval()
        this.intervalId = setInterval(this.onInterval.bind(this), this.interval);
    };
    /**
     * Queue a new error.
     *
     * @param e    - Error object
     * @param info - Extra Error Info (Consider using "type" field)
     */
    Logger.prototype.onError = function (e, info) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var message, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!Logger.isValidError(e) || !this.enabled) {
                            return [2 /*return*/];
                        }
                        if (!this.messageFormatter) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.messageFormatter(e, info)]; // Custom formatter
                    case 1:
                        _a = _b.sent(); // Custom formatter
                        return [3 /*break*/, 3];
                    case 2:
                        _a = JSON.stringify(tslib_1.__assign({ message: e.message }, info));
                        _b.label = 3;
                    case 3:
                        message = _a;
                        // Abort when received null
                        if (!message) {
                            return [2 /*return*/];
                        }
                        this.events.push({
                            timestamp: new Date().getTime(),
                            message: message,
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Send queued errors.
     */
    Logger.prototype.onInterval = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var pendingEvents, logStreamName, sequenceToken, command, nextSequenceToken, needsRetry, e_2;
            var _a, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!this.enabled) {
                            return [2 /*return*/];
                        }
                        pendingEvents = this.events.splice(0);
                        if (!pendingEvents.length) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.getLogStreamName()];
                    case 1:
                        logStreamName = _c.sent();
                        if (!logStreamName) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.getCache('sequenceToken')];
                    case 2:
                        sequenceToken = _c.sent();
                        command = new client_cloudwatch_logs_1.PutLogEventsCommand(tslib_1.__assign({ logEvents: pendingEvents, logGroupName: this.logGroupName, logStreamName: logStreamName }, (sequenceToken ? { sequenceToken: sequenceToken } : undefined)));
                        nextSequenceToken = undefined;
                        needsRetry = false;
                        _c.label = 3;
                    case 3:
                        _c.trys.push([3, 5, , 8]);
                        return [4 /*yield*/, this.getClient().send(command)];
                    case 4:
                        // Run request to send events and retrieve fresh "nextSequenceToken"
                        (_a = (_c.sent()).nextSequenceToken, nextSequenceToken = _a === void 0 ? undefined : _a);
                        return [3 /*break*/, 8];
                    case 5:
                        e_2 = _c.sent();
                        if (!(!Logger.isValidError(e_2) ||
                            (e_2.name !== 'DataAlreadyAcceptedException' &&
                                e_2.name !== 'InvalidSequenceTokenException') ||
                            !e_2.expectedSequenceToken)) return [3 /*break*/, 7];
                        // Print error to original console and reset states
                        this.getConsole().error(e_2);
                        return [4 /*yield*/, this.refresh()];
                    case 6:
                        _c.sent();
                        return [2 /*return*/];
                    case 7:
                        // Recover from InvalidSequenceTokenException error message
                        nextSequenceToken = e_2.expectedSequenceToken;
                        needsRetry = e_2.name !== 'DataAlreadyAcceptedException';
                        return [3 /*break*/, 8];
                    case 8:
                        if (!nextSequenceToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, this.setCache('sequenceToken', nextSequenceToken)];
                    case 9:
                        _c.sent();
                        _c.label = 10;
                    case 10:
                        // Immediately retry after recovery
                        if (needsRetry) {
                            (_b = this.events).push.apply(_b, tslib_1.__spreadArray([], tslib_1.__read(pendingEvents)));
                            setTimeout(this.onInterval, 0);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Logger.prototype.getClient = function () {
        if (!this.client) {
            throw new Error('Not yet installed');
        }
        return this.client;
    };
    Logger.prototype.getStorage = function () {
        if (!this.storage) {
            throw new Error('Not yet installed');
        }
        return this.storage;
    };
    Logger.prototype.getConsole = function () {
        if (!this.console) {
            throw new Error('Not yet installed');
        }
        return this.console;
    };
    Logger.prototype.setCache = function (key, value) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getStorage().setItem(Logger.namespace + ":" + key, value)];
            });
        });
    };
    Logger.prototype.getCache = function (key) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getStorage().getItem(Logger.namespace + ":" + key)];
            });
        });
    };
    Logger.prototype.deleteCache = function (key) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getStorage().removeItem(Logger.namespace + ":" + key)];
            });
        });
    };
    Logger.prototype.refresh = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.deleteCache('logStreamName')];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.deleteCache('sequenceToken')];
                    case 2:
                        _a.sent();
                        this.events.splice(0);
                        return [2 /*return*/];
                }
            });
        });
    };
    Logger.prototype.getLogStreamName = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var retrieved, logStreamName, _a, createLogStreamCommand, e_3;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getCache('logStreamName')];
                    case 1:
                        retrieved = _b.sent();
                        if (retrieved) {
                            return [2 /*return*/, retrieved];
                        }
                        _a = this.logStreamNameResolver;
                        if (!_a) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.logStreamNameResolver()];
                    case 2:
                        _a = (_b.sent());
                        _b.label = 3;
                    case 3:
                        logStreamName = (_a) || // Resolve for current user (e.g. Canvas Fingerprint)
                            Logger.defaultLogStreamName;
                        createLogStreamCommand = new client_cloudwatch_logs_1.CreateLogStreamCommand({
                            logGroupName: this.logGroupName,
                            logStreamName: logStreamName,
                        });
                        _b.label = 4;
                    case 4:
                        _b.trys.push([4, 6, , 9]);
                        // Run request to create a new logStream
                        return [4 /*yield*/, this.getClient().send(createLogStreamCommand)];
                    case 5:
                        // Run request to create a new logStream
                        _b.sent();
                        return [3 /*break*/, 9];
                    case 6:
                        e_3 = _b.sent();
                        if (!(!Logger.isValidError(e_3) ||
                            e_3.name !== 'ResourceAlreadyExistsException')) return [3 /*break*/, 8];
                        // Print error to original console and reset states
                        this.getConsole().error(e_3);
                        return [4 /*yield*/, this.refresh()];
                    case 7:
                        _b.sent();
                        return [2 /*return*/, null];
                    case 8: return [3 /*break*/, 9];
                    case 9: 
                    // Cache fresh "logStreamName"
                    return [4 /*yield*/, this.setCache('logStreamName', logStreamName)];
                    case 10:
                        // Cache fresh "logStreamName"
                        _b.sent();
                        return [2 /*return*/, logStreamName];
                }
            });
        });
    };
    Logger.isValidError = function (value) {
        return Boolean(value && typeof value.message === 'string');
    };
    Logger.namespace = 'CloudWatchFrontLogger';
    Logger.defaultLogStreamName = 'anonymous';
    return Logger;
}());
exports.default = Logger;
